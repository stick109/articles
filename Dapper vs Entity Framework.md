## What people on Reddit are saying

**McWobbleston**

I'm surprised no one's mentioned picking Dapper over EF to "keep it simple". As much as I appreciate the idea of an ORM, that usually comes with learning a new set of abstractions, configurations, processes, footguns, etc. I'm personally averse to a lot of the design choices and the way Microsoft lays out documentation for their frameworks. My first experience with EF was ~2012 and found it pleasant once I got going, but wasn't exactly worth the time over a simple mapper like Dapper when you already know SQL.

**Prudent_Astronaut716**

I gave EF multiple chances but never liked it. Maybe I am a control freak... I want to write my queries myself and optimize them... all I need is a simple object mapper. EF is overkill for me.

**i8beef**

Do you buy the minivan with the 23 cup holders and the built in central vacuum and 3 screen entertainment system, or do you want to buy a WRX that you are going to tune and race? You buy EF for what it gives you. You buy Dapper for what it doesn't. 
I tend to hate EF because I don't like abstracting away SQL. Every time I use EF I end up turning off half of what it gives you anyway, at which point I just ask why I didn't use Dapper in the first place. I'm more of a bare metal person though. Give me direct SQL access any day.

**soAsian**

EF to me is too heavy. You need to know the query that is generated anyway. To me using SQL with data is better.

**Zardotab**

We use Dapper because EF has a long learning curve, and we use mostly stored procedures, which Dapper works well with. EF makes most query tasks easy, but if you get stuck it can be a bear to troubleshoot. There's less middlemen processing going on in Dapper, meaning less mysteries to unravel. I want to get work done, not play Scooby Doo.

**deleted**

I also prefer Dapper over EF. The EF learning curve is too high, I already know SQL, and that's the only pre-requisite to use Dapper. I also don't want to get rusty on my SQL skills. Dapper helped develop those skills. EF just feels like pointless abstraction.

**chucara**

We use almost exclusively Dapper. Yes, there are performance improvements for the mapping part in the more recent versions of EF, but subtle differences in the SQL means an index not being hit or too much data being fetched, so we most frequently write SQL ourselves. This means that we don't really use the majority of the features in EF. And in our case, we find Dapper to be a much simpler beast.

**japinthebox**

Problem for me with EF has been that it's really easy to shoot yourself in the foot. And the error messages suck. I'm not convinced that the programming model is really compatible with modern C# anymore. You might query for something, forget that you haven't included something, and even when you're using non-nullable types, you get a null result. Then you pass that off to some other insert query, and it just gives you a cryptic, unsanitized exception message about a missing IDictionary key somewhere deep inside its guts.

## Analysis

As you can see, there are a lot of different reasons to prefer Dapper over EF. Can we find common parts?

#### Maturity

It seems that more mature/experienced developer is, the more he/she prefers Dapper over EF. Some of developers articulate reasons well, for some it's more of a "gut feeling" (which is still valuable and shouldn't be easily discarded).

#### Leaking abstraction

EF tries to "abstract away" SQL. Does it work? Only in special circumstances, the ones that rarely happen in real life. What are those circumstances?

1. All tables are small, there is no big difference between query plan that scans every table and plan that uses indices properly
2. Queries are simple, there is no possibility - for example - for mistakenly using inner join instead of outer join or vice versa - or any other logical error

As soon as either (1) or (2) does not hold, EF abstraction is leaking very badly in that not only you need to turn to SQL to find out what the problem is, you have to deal with SQL generated by EF, which is both hard to read and hard to get to in the first place.

The same point can be re-phrased differently. If you don't have SQL expertise in house, you are guaranteed to have problems, sooner rather than later, regardless of whether you use Dapper or EF. Using Dapper allows you to grow your team's SQL expertise gradually, so the team is ready to solve problems that appear when codebase complexity grows. With EF, the same problem will be hidden under more layers of abstraction and team will have less expertise to solve it.

#### Pay as you go

With Dapper, the entry barrier is low, you can get to MVP faster, all you need to start is to install Nuget package. With EF, you need to learn its abstractions before you can start using it.
